import{_ as e,o,c,a}from"./app-Js4EkCke.js";const d={},p=a('<h3 id="微前端" tabindex="-1"><a class="header-anchor" href="#微前端"><span>微前端</span></a></h3><p>微前端的概念是由ThoughtWorks在2016年提出的，它借鉴了微服务的架构理念，核心在于将一个庞大的前端应用拆分成多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独立部署，再将这些小型应用融合为一个完整的应用，或者将原本运行已久、没有关联的几个应用融合为一个应用。微前端既可以将多个项目融合为一，又可以减少项目之间的耦合，提升项目扩展性，相比一整块的前端仓库，微前端架构下的前端仓库倾向于更小更灵活。</p><p>它主要解决了两个问题：</p><ul><li>1、随着项目迭代应用越来越庞大，难以维护。</li><li>2、跨团队或跨部门协作开发项目导致效率低下的问题。</li></ul><p><img src="https://img13.360buyimg.com/imagetools/jfs/t1/182098/24/20562/94562/6123569cE7a4b5bc3/f135ab0912746bd6.png" alt="microfroentend" title=":size=750"></p><h3 id="关于micro-app" tabindex="-1"><a class="header-anchor" href="#关于micro-app"><span>关于micro-app</span></a></h3><p>在<code>micro-app</code>之前，业内已经有一些开源的微前端框架，比较流行的有2个：<code>single-spa</code>和<code>qiankun</code>。</p><p><code>single-spa</code>是通过监听 url change 事件，在路由变化时匹配到渲染的子应用并进行渲染，这个思路也是目前实现微前端的主流方式。同时<code>single-spa</code>要求子应用修改渲染逻辑并暴露出三个方法：<code>bootstrap</code>、<code>mount</code>、<code>unmount</code>，分别对应初始化、渲染和卸载，这也导致子应用需要对入口文件进行修改。因为<code>qiankun</code>是基于<code>single-spa</code>进行封装，所以这些特点也被<code>qiankun</code>继承下来，并且需要对webpack配置进行一些修改。</p><p><code>micro-app</code>并没有沿袭<code>single-spa</code>的思路，而是借鉴了WebComponent的思想，通过CustomElement结合自定义的ShadowDom，将微前端封装成一个类WebComponent组件，从而实现微前端的组件化渲染。并且由于自定义ShadowDom的隔离特性，<code>micro-app</code>不需要像<code>single-spa</code>和<code>qiankun</code>一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改webpack配置，是目前市面上接入微前端成本最低的方案。</p><h5 id="概念图" tabindex="-1"><a class="header-anchor" href="#概念图"><span>概念图</span></a></h5><p><img src="https://img10.360buyimg.com/imagetools/jfs/t1/168885/23/20790/54203/6084d445E0c9ec00e/d879637b4bb34253.png" alt="image" title=":size=750"></p><h3 id="micro-app的优势" tabindex="-1"><a class="header-anchor" href="#micro-app的优势"><span>micro-app的优势</span></a></h3><h4 id="_1、使用简单" tabindex="-1"><a class="header-anchor" href="#_1、使用简单"><span>1、使用简单</span></a></h4><p>我们将所有功能都封装到一个类WebComponent组件中，从而实现在基座应用中嵌入一行代码即可渲染一个微前端应用。</p><p>同时<code>micro-app</code>还提供了<code>js沙箱</code>、<code>样式隔离</code>、<code>元素隔离</code>、<code>预加载</code>、<code>数据通信</code>、<code>静态资源补全</code>等一系列完善的功能。</p><h4 id="_2、零依赖" tabindex="-1"><a class="header-anchor" href="#_2、零依赖"><span>2、零依赖</span></a></h4><p><code>micro-app</code>没有任何依赖，这赋予它小巧的体积和更高的扩展性。</p><h4 id="_3、兼容所有框架" tabindex="-1"><a class="header-anchor" href="#_3、兼容所有框架"><span>3、兼容所有框架</span></a></h4><p>为了保证各个业务之间独立开发、独立部署的能力，<code>micro-app</code>做了诸多兼容，在任何技术框架中都可以正常运行。</p>',19),n=[p];function s(i,r){return o(),c("div",null,n)}const h=e(d,[["render",s],["__file","index.html.vue"]]);export{h as default};
